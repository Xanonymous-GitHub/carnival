// Code generated by entc, DO NOT EDIT.

package application

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Xanonymous-GitHub/carnival/db/ent/predicate"
	"github.com/Xanonymous-GitHub/carnival/db/ent/schema"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// BasicID applies equality check predicate on the "basic_id" field. It's identical to BasicIDEQ.
func BasicID(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBasicID), v))
	})
}

// PremiumID applies equality check predicate on the "premium_id" field. It's identical to PremiumIDEQ.
func PremiumID(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPremiumID), v))
	})
}

// BotDisplayName applies equality check predicate on the "bot_display_name" field. It's identical to BotDisplayNameEQ.
func BotDisplayName(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBotDisplayName), v))
	})
}

// BotMid applies equality check predicate on the "bot_mid" field. It's identical to BotMidEQ.
func BotMid(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBotMid), v))
	})
}

// ApplicantName applies equality check predicate on the "applicant_name" field. It's identical to ApplicantNameEQ.
func ApplicantName(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplicantName), v))
	})
}

// ApplicantEmail applies equality check predicate on the "applicant_email" field. It's identical to ApplicantEmailEQ.
func ApplicantEmail(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplicantEmail), v))
	})
}

// ApplicationMid applies equality check predicate on the "application_mid" field. It's identical to ApplicationMidEQ.
func ApplicationMid(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplicationMid), v))
	})
}

// Remark applies equality check predicate on the "remark" field. It's identical to RemarkEQ.
func Remark(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemark), v))
	})
}

// WebsiteURL applies equality check predicate on the "website_url" field. It's identical to WebsiteURLEQ.
func WebsiteURL(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWebsiteURL), v))
	})
}

// ReviewComment applies equality check predicate on the "review_comment" field. It's identical to ReviewCommentEQ.
func ReviewComment(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReviewComment), v))
	})
}

// Assigner applies equality check predicate on the "assigner" field. It's identical to AssignerEQ.
func Assigner(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAssigner), v))
	})
}

// Assignee applies equality check predicate on the "assignee" field. It's identical to AssigneeEQ.
func Assignee(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAssignee), v))
	})
}

// CreatedDtime applies equality check predicate on the "created_dtime" field. It's identical to CreatedDtimeEQ.
func CreatedDtime(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedDtime), v))
	})
}

// UpdateDtime applies equality check predicate on the "update_dtime" field. It's identical to UpdateDtimeEQ.
func UpdateDtime(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateDtime), v))
	})
}

// BasicIDEQ applies the EQ predicate on the "basic_id" field.
func BasicIDEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBasicID), v))
	})
}

// BasicIDNEQ applies the NEQ predicate on the "basic_id" field.
func BasicIDNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBasicID), v))
	})
}

// BasicIDIn applies the In predicate on the "basic_id" field.
func BasicIDIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBasicID), v...))
	})
}

// BasicIDNotIn applies the NotIn predicate on the "basic_id" field.
func BasicIDNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBasicID), v...))
	})
}

// BasicIDGT applies the GT predicate on the "basic_id" field.
func BasicIDGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBasicID), v))
	})
}

// BasicIDGTE applies the GTE predicate on the "basic_id" field.
func BasicIDGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBasicID), v))
	})
}

// BasicIDLT applies the LT predicate on the "basic_id" field.
func BasicIDLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBasicID), v))
	})
}

// BasicIDLTE applies the LTE predicate on the "basic_id" field.
func BasicIDLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBasicID), v))
	})
}

// BasicIDContains applies the Contains predicate on the "basic_id" field.
func BasicIDContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBasicID), v))
	})
}

// BasicIDHasPrefix applies the HasPrefix predicate on the "basic_id" field.
func BasicIDHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBasicID), v))
	})
}

// BasicIDHasSuffix applies the HasSuffix predicate on the "basic_id" field.
func BasicIDHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBasicID), v))
	})
}

// BasicIDEqualFold applies the EqualFold predicate on the "basic_id" field.
func BasicIDEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBasicID), v))
	})
}

// BasicIDContainsFold applies the ContainsFold predicate on the "basic_id" field.
func BasicIDContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBasicID), v))
	})
}

// PremiumIDEQ applies the EQ predicate on the "premium_id" field.
func PremiumIDEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPremiumID), v))
	})
}

// PremiumIDNEQ applies the NEQ predicate on the "premium_id" field.
func PremiumIDNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPremiumID), v))
	})
}

// PremiumIDIn applies the In predicate on the "premium_id" field.
func PremiumIDIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPremiumID), v...))
	})
}

// PremiumIDNotIn applies the NotIn predicate on the "premium_id" field.
func PremiumIDNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPremiumID), v...))
	})
}

// PremiumIDGT applies the GT predicate on the "premium_id" field.
func PremiumIDGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPremiumID), v))
	})
}

// PremiumIDGTE applies the GTE predicate on the "premium_id" field.
func PremiumIDGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPremiumID), v))
	})
}

// PremiumIDLT applies the LT predicate on the "premium_id" field.
func PremiumIDLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPremiumID), v))
	})
}

// PremiumIDLTE applies the LTE predicate on the "premium_id" field.
func PremiumIDLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPremiumID), v))
	})
}

// PremiumIDContains applies the Contains predicate on the "premium_id" field.
func PremiumIDContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPremiumID), v))
	})
}

// PremiumIDHasPrefix applies the HasPrefix predicate on the "premium_id" field.
func PremiumIDHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPremiumID), v))
	})
}

// PremiumIDHasSuffix applies the HasSuffix predicate on the "premium_id" field.
func PremiumIDHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPremiumID), v))
	})
}

// PremiumIDEqualFold applies the EqualFold predicate on the "premium_id" field.
func PremiumIDEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPremiumID), v))
	})
}

// PremiumIDContainsFold applies the ContainsFold predicate on the "premium_id" field.
func PremiumIDContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPremiumID), v))
	})
}

// BotDisplayNameEQ applies the EQ predicate on the "bot_display_name" field.
func BotDisplayNameEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameNEQ applies the NEQ predicate on the "bot_display_name" field.
func BotDisplayNameNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameIn applies the In predicate on the "bot_display_name" field.
func BotDisplayNameIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBotDisplayName), v...))
	})
}

// BotDisplayNameNotIn applies the NotIn predicate on the "bot_display_name" field.
func BotDisplayNameNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBotDisplayName), v...))
	})
}

// BotDisplayNameGT applies the GT predicate on the "bot_display_name" field.
func BotDisplayNameGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameGTE applies the GTE predicate on the "bot_display_name" field.
func BotDisplayNameGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameLT applies the LT predicate on the "bot_display_name" field.
func BotDisplayNameLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameLTE applies the LTE predicate on the "bot_display_name" field.
func BotDisplayNameLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameContains applies the Contains predicate on the "bot_display_name" field.
func BotDisplayNameContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameHasPrefix applies the HasPrefix predicate on the "bot_display_name" field.
func BotDisplayNameHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameHasSuffix applies the HasSuffix predicate on the "bot_display_name" field.
func BotDisplayNameHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameEqualFold applies the EqualFold predicate on the "bot_display_name" field.
func BotDisplayNameEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBotDisplayName), v))
	})
}

// BotDisplayNameContainsFold applies the ContainsFold predicate on the "bot_display_name" field.
func BotDisplayNameContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBotDisplayName), v))
	})
}

// BotMidEQ applies the EQ predicate on the "bot_mid" field.
func BotMidEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBotMid), v))
	})
}

// BotMidNEQ applies the NEQ predicate on the "bot_mid" field.
func BotMidNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBotMid), v))
	})
}

// BotMidIn applies the In predicate on the "bot_mid" field.
func BotMidIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBotMid), v...))
	})
}

// BotMidNotIn applies the NotIn predicate on the "bot_mid" field.
func BotMidNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBotMid), v...))
	})
}

// BotMidGT applies the GT predicate on the "bot_mid" field.
func BotMidGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBotMid), v))
	})
}

// BotMidGTE applies the GTE predicate on the "bot_mid" field.
func BotMidGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBotMid), v))
	})
}

// BotMidLT applies the LT predicate on the "bot_mid" field.
func BotMidLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBotMid), v))
	})
}

// BotMidLTE applies the LTE predicate on the "bot_mid" field.
func BotMidLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBotMid), v))
	})
}

// BotMidContains applies the Contains predicate on the "bot_mid" field.
func BotMidContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBotMid), v))
	})
}

// BotMidHasPrefix applies the HasPrefix predicate on the "bot_mid" field.
func BotMidHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBotMid), v))
	})
}

// BotMidHasSuffix applies the HasSuffix predicate on the "bot_mid" field.
func BotMidHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBotMid), v))
	})
}

// BotMidEqualFold applies the EqualFold predicate on the "bot_mid" field.
func BotMidEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBotMid), v))
	})
}

// BotMidContainsFold applies the ContainsFold predicate on the "bot_mid" field.
func BotMidContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBotMid), v))
	})
}

// BotActiveStatusEQ applies the EQ predicate on the "bot_active_status" field.
func BotActiveStatusEQ(v schema.BotActiveStatus) predicate.Application {
	vc := v
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBotActiveStatus), vc))
	})
}

// BotActiveStatusNEQ applies the NEQ predicate on the "bot_active_status" field.
func BotActiveStatusNEQ(v schema.BotActiveStatus) predicate.Application {
	vc := v
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBotActiveStatus), vc))
	})
}

// BotActiveStatusIn applies the In predicate on the "bot_active_status" field.
func BotActiveStatusIn(vs ...schema.BotActiveStatus) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBotActiveStatus), v...))
	})
}

// BotActiveStatusNotIn applies the NotIn predicate on the "bot_active_status" field.
func BotActiveStatusNotIn(vs ...schema.BotActiveStatus) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBotActiveStatus), v...))
	})
}

// ApplicantNameEQ applies the EQ predicate on the "applicant_name" field.
func ApplicantNameEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameNEQ applies the NEQ predicate on the "applicant_name" field.
func ApplicantNameNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameIn applies the In predicate on the "applicant_name" field.
func ApplicantNameIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldApplicantName), v...))
	})
}

// ApplicantNameNotIn applies the NotIn predicate on the "applicant_name" field.
func ApplicantNameNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldApplicantName), v...))
	})
}

// ApplicantNameGT applies the GT predicate on the "applicant_name" field.
func ApplicantNameGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameGTE applies the GTE predicate on the "applicant_name" field.
func ApplicantNameGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameLT applies the LT predicate on the "applicant_name" field.
func ApplicantNameLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameLTE applies the LTE predicate on the "applicant_name" field.
func ApplicantNameLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameContains applies the Contains predicate on the "applicant_name" field.
func ApplicantNameContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameHasPrefix applies the HasPrefix predicate on the "applicant_name" field.
func ApplicantNameHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameHasSuffix applies the HasSuffix predicate on the "applicant_name" field.
func ApplicantNameHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameEqualFold applies the EqualFold predicate on the "applicant_name" field.
func ApplicantNameEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldApplicantName), v))
	})
}

// ApplicantNameContainsFold applies the ContainsFold predicate on the "applicant_name" field.
func ApplicantNameContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldApplicantName), v))
	})
}

// ApplicantEmailEQ applies the EQ predicate on the "applicant_email" field.
func ApplicantEmailEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailNEQ applies the NEQ predicate on the "applicant_email" field.
func ApplicantEmailNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailIn applies the In predicate on the "applicant_email" field.
func ApplicantEmailIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldApplicantEmail), v...))
	})
}

// ApplicantEmailNotIn applies the NotIn predicate on the "applicant_email" field.
func ApplicantEmailNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldApplicantEmail), v...))
	})
}

// ApplicantEmailGT applies the GT predicate on the "applicant_email" field.
func ApplicantEmailGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailGTE applies the GTE predicate on the "applicant_email" field.
func ApplicantEmailGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailLT applies the LT predicate on the "applicant_email" field.
func ApplicantEmailLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailLTE applies the LTE predicate on the "applicant_email" field.
func ApplicantEmailLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailContains applies the Contains predicate on the "applicant_email" field.
func ApplicantEmailContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailHasPrefix applies the HasPrefix predicate on the "applicant_email" field.
func ApplicantEmailHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailHasSuffix applies the HasSuffix predicate on the "applicant_email" field.
func ApplicantEmailHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailEqualFold applies the EqualFold predicate on the "applicant_email" field.
func ApplicantEmailEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldApplicantEmail), v))
	})
}

// ApplicantEmailContainsFold applies the ContainsFold predicate on the "applicant_email" field.
func ApplicantEmailContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldApplicantEmail), v))
	})
}

// ApplicationMidEQ applies the EQ predicate on the "application_mid" field.
func ApplicationMidEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidNEQ applies the NEQ predicate on the "application_mid" field.
func ApplicationMidNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidIn applies the In predicate on the "application_mid" field.
func ApplicationMidIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldApplicationMid), v...))
	})
}

// ApplicationMidNotIn applies the NotIn predicate on the "application_mid" field.
func ApplicationMidNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldApplicationMid), v...))
	})
}

// ApplicationMidGT applies the GT predicate on the "application_mid" field.
func ApplicationMidGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidGTE applies the GTE predicate on the "application_mid" field.
func ApplicationMidGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidLT applies the LT predicate on the "application_mid" field.
func ApplicationMidLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidLTE applies the LTE predicate on the "application_mid" field.
func ApplicationMidLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidContains applies the Contains predicate on the "application_mid" field.
func ApplicationMidContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidHasPrefix applies the HasPrefix predicate on the "application_mid" field.
func ApplicationMidHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidHasSuffix applies the HasSuffix predicate on the "application_mid" field.
func ApplicationMidHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidEqualFold applies the EqualFold predicate on the "application_mid" field.
func ApplicationMidEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldApplicationMid), v))
	})
}

// ApplicationMidContainsFold applies the ContainsFold predicate on the "application_mid" field.
func ApplicationMidContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldApplicationMid), v))
	})
}

// RemarkEQ applies the EQ predicate on the "remark" field.
func RemarkEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRemark), v))
	})
}

// RemarkNEQ applies the NEQ predicate on the "remark" field.
func RemarkNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRemark), v))
	})
}

// RemarkIn applies the In predicate on the "remark" field.
func RemarkIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRemark), v...))
	})
}

// RemarkNotIn applies the NotIn predicate on the "remark" field.
func RemarkNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRemark), v...))
	})
}

// RemarkGT applies the GT predicate on the "remark" field.
func RemarkGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRemark), v))
	})
}

// RemarkGTE applies the GTE predicate on the "remark" field.
func RemarkGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRemark), v))
	})
}

// RemarkLT applies the LT predicate on the "remark" field.
func RemarkLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRemark), v))
	})
}

// RemarkLTE applies the LTE predicate on the "remark" field.
func RemarkLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRemark), v))
	})
}

// RemarkContains applies the Contains predicate on the "remark" field.
func RemarkContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRemark), v))
	})
}

// RemarkHasPrefix applies the HasPrefix predicate on the "remark" field.
func RemarkHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRemark), v))
	})
}

// RemarkHasSuffix applies the HasSuffix predicate on the "remark" field.
func RemarkHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRemark), v))
	})
}

// RemarkEqualFold applies the EqualFold predicate on the "remark" field.
func RemarkEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRemark), v))
	})
}

// RemarkContainsFold applies the ContainsFold predicate on the "remark" field.
func RemarkContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRemark), v))
	})
}

// StoreTypeEQ applies the EQ predicate on the "store_type" field.
func StoreTypeEQ(v schema.StoreType) predicate.Application {
	vc := v
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStoreType), vc))
	})
}

// StoreTypeNEQ applies the NEQ predicate on the "store_type" field.
func StoreTypeNEQ(v schema.StoreType) predicate.Application {
	vc := v
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStoreType), vc))
	})
}

// StoreTypeIn applies the In predicate on the "store_type" field.
func StoreTypeIn(vs ...schema.StoreType) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStoreType), v...))
	})
}

// StoreTypeNotIn applies the NotIn predicate on the "store_type" field.
func StoreTypeNotIn(vs ...schema.StoreType) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStoreType), v...))
	})
}

// WebsiteURLEQ applies the EQ predicate on the "website_url" field.
func WebsiteURLEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLNEQ applies the NEQ predicate on the "website_url" field.
func WebsiteURLNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLIn applies the In predicate on the "website_url" field.
func WebsiteURLIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWebsiteURL), v...))
	})
}

// WebsiteURLNotIn applies the NotIn predicate on the "website_url" field.
func WebsiteURLNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWebsiteURL), v...))
	})
}

// WebsiteURLGT applies the GT predicate on the "website_url" field.
func WebsiteURLGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLGTE applies the GTE predicate on the "website_url" field.
func WebsiteURLGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLLT applies the LT predicate on the "website_url" field.
func WebsiteURLLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLLTE applies the LTE predicate on the "website_url" field.
func WebsiteURLLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLContains applies the Contains predicate on the "website_url" field.
func WebsiteURLContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLHasPrefix applies the HasPrefix predicate on the "website_url" field.
func WebsiteURLHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLHasSuffix applies the HasSuffix predicate on the "website_url" field.
func WebsiteURLHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLEqualFold applies the EqualFold predicate on the "website_url" field.
func WebsiteURLEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWebsiteURL), v))
	})
}

// WebsiteURLContainsFold applies the ContainsFold predicate on the "website_url" field.
func WebsiteURLContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWebsiteURL), v))
	})
}

// ApplicationStatusEQ applies the EQ predicate on the "application_status" field.
func ApplicationStatusEQ(v schema.ApplicationStatus) predicate.Application {
	vc := v
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApplicationStatus), vc))
	})
}

// ApplicationStatusNEQ applies the NEQ predicate on the "application_status" field.
func ApplicationStatusNEQ(v schema.ApplicationStatus) predicate.Application {
	vc := v
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldApplicationStatus), vc))
	})
}

// ApplicationStatusIn applies the In predicate on the "application_status" field.
func ApplicationStatusIn(vs ...schema.ApplicationStatus) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldApplicationStatus), v...))
	})
}

// ApplicationStatusNotIn applies the NotIn predicate on the "application_status" field.
func ApplicationStatusNotIn(vs ...schema.ApplicationStatus) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldApplicationStatus), v...))
	})
}

// ReviewCommentEQ applies the EQ predicate on the "review_comment" field.
func ReviewCommentEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentNEQ applies the NEQ predicate on the "review_comment" field.
func ReviewCommentNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentIn applies the In predicate on the "review_comment" field.
func ReviewCommentIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldReviewComment), v...))
	})
}

// ReviewCommentNotIn applies the NotIn predicate on the "review_comment" field.
func ReviewCommentNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldReviewComment), v...))
	})
}

// ReviewCommentGT applies the GT predicate on the "review_comment" field.
func ReviewCommentGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentGTE applies the GTE predicate on the "review_comment" field.
func ReviewCommentGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentLT applies the LT predicate on the "review_comment" field.
func ReviewCommentLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentLTE applies the LTE predicate on the "review_comment" field.
func ReviewCommentLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentContains applies the Contains predicate on the "review_comment" field.
func ReviewCommentContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentHasPrefix applies the HasPrefix predicate on the "review_comment" field.
func ReviewCommentHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentHasSuffix applies the HasSuffix predicate on the "review_comment" field.
func ReviewCommentHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentEqualFold applies the EqualFold predicate on the "review_comment" field.
func ReviewCommentEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldReviewComment), v))
	})
}

// ReviewCommentContainsFold applies the ContainsFold predicate on the "review_comment" field.
func ReviewCommentContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldReviewComment), v))
	})
}

// AssignerEQ applies the EQ predicate on the "assigner" field.
func AssignerEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAssigner), v))
	})
}

// AssignerNEQ applies the NEQ predicate on the "assigner" field.
func AssignerNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAssigner), v))
	})
}

// AssignerIn applies the In predicate on the "assigner" field.
func AssignerIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAssigner), v...))
	})
}

// AssignerNotIn applies the NotIn predicate on the "assigner" field.
func AssignerNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAssigner), v...))
	})
}

// AssignerGT applies the GT predicate on the "assigner" field.
func AssignerGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAssigner), v))
	})
}

// AssignerGTE applies the GTE predicate on the "assigner" field.
func AssignerGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAssigner), v))
	})
}

// AssignerLT applies the LT predicate on the "assigner" field.
func AssignerLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAssigner), v))
	})
}

// AssignerLTE applies the LTE predicate on the "assigner" field.
func AssignerLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAssigner), v))
	})
}

// AssignerContains applies the Contains predicate on the "assigner" field.
func AssignerContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAssigner), v))
	})
}

// AssignerHasPrefix applies the HasPrefix predicate on the "assigner" field.
func AssignerHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAssigner), v))
	})
}

// AssignerHasSuffix applies the HasSuffix predicate on the "assigner" field.
func AssignerHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAssigner), v))
	})
}

// AssignerEqualFold applies the EqualFold predicate on the "assigner" field.
func AssignerEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAssigner), v))
	})
}

// AssignerContainsFold applies the ContainsFold predicate on the "assigner" field.
func AssignerContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAssigner), v))
	})
}

// AssigneeEQ applies the EQ predicate on the "assignee" field.
func AssigneeEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAssignee), v))
	})
}

// AssigneeNEQ applies the NEQ predicate on the "assignee" field.
func AssigneeNEQ(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAssignee), v))
	})
}

// AssigneeIn applies the In predicate on the "assignee" field.
func AssigneeIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAssignee), v...))
	})
}

// AssigneeNotIn applies the NotIn predicate on the "assignee" field.
func AssigneeNotIn(vs ...string) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAssignee), v...))
	})
}

// AssigneeGT applies the GT predicate on the "assignee" field.
func AssigneeGT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAssignee), v))
	})
}

// AssigneeGTE applies the GTE predicate on the "assignee" field.
func AssigneeGTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAssignee), v))
	})
}

// AssigneeLT applies the LT predicate on the "assignee" field.
func AssigneeLT(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAssignee), v))
	})
}

// AssigneeLTE applies the LTE predicate on the "assignee" field.
func AssigneeLTE(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAssignee), v))
	})
}

// AssigneeContains applies the Contains predicate on the "assignee" field.
func AssigneeContains(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAssignee), v))
	})
}

// AssigneeHasPrefix applies the HasPrefix predicate on the "assignee" field.
func AssigneeHasPrefix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAssignee), v))
	})
}

// AssigneeHasSuffix applies the HasSuffix predicate on the "assignee" field.
func AssigneeHasSuffix(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAssignee), v))
	})
}

// AssigneeEqualFold applies the EqualFold predicate on the "assignee" field.
func AssigneeEqualFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAssignee), v))
	})
}

// AssigneeContainsFold applies the ContainsFold predicate on the "assignee" field.
func AssigneeContainsFold(v string) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAssignee), v))
	})
}

// CreatedDtimeEQ applies the EQ predicate on the "created_dtime" field.
func CreatedDtimeEQ(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedDtime), v))
	})
}

// CreatedDtimeNEQ applies the NEQ predicate on the "created_dtime" field.
func CreatedDtimeNEQ(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedDtime), v))
	})
}

// CreatedDtimeIn applies the In predicate on the "created_dtime" field.
func CreatedDtimeIn(vs ...time.Time) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedDtime), v...))
	})
}

// CreatedDtimeNotIn applies the NotIn predicate on the "created_dtime" field.
func CreatedDtimeNotIn(vs ...time.Time) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedDtime), v...))
	})
}

// CreatedDtimeGT applies the GT predicate on the "created_dtime" field.
func CreatedDtimeGT(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedDtime), v))
	})
}

// CreatedDtimeGTE applies the GTE predicate on the "created_dtime" field.
func CreatedDtimeGTE(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedDtime), v))
	})
}

// CreatedDtimeLT applies the LT predicate on the "created_dtime" field.
func CreatedDtimeLT(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedDtime), v))
	})
}

// CreatedDtimeLTE applies the LTE predicate on the "created_dtime" field.
func CreatedDtimeLTE(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedDtime), v))
	})
}

// UpdateDtimeEQ applies the EQ predicate on the "update_dtime" field.
func UpdateDtimeEQ(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateDtime), v))
	})
}

// UpdateDtimeNEQ applies the NEQ predicate on the "update_dtime" field.
func UpdateDtimeNEQ(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateDtime), v))
	})
}

// UpdateDtimeIn applies the In predicate on the "update_dtime" field.
func UpdateDtimeIn(vs ...time.Time) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateDtime), v...))
	})
}

// UpdateDtimeNotIn applies the NotIn predicate on the "update_dtime" field.
func UpdateDtimeNotIn(vs ...time.Time) predicate.Application {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Application(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateDtime), v...))
	})
}

// UpdateDtimeGT applies the GT predicate on the "update_dtime" field.
func UpdateDtimeGT(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateDtime), v))
	})
}

// UpdateDtimeGTE applies the GTE predicate on the "update_dtime" field.
func UpdateDtimeGTE(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateDtime), v))
	})
}

// UpdateDtimeLT applies the LT predicate on the "update_dtime" field.
func UpdateDtimeLT(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateDtime), v))
	})
}

// UpdateDtimeLTE applies the LTE predicate on the "update_dtime" field.
func UpdateDtimeLTE(v time.Time) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateDtime), v))
	})
}

// HasTickets applies the HasEdge predicate on the "tickets" edge.
func HasTickets() predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TicketsTable, TicketFieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, TicketsTable, TicketsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTicketsWith applies the HasEdge predicate on the "tickets" edge with a given conditions (other predicates).
func HasTicketsWith(preds ...predicate.Ticket) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TicketsInverseTable, TicketFieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, TicketsTable, TicketsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAssignmentHistories applies the HasEdge predicate on the "assignment_histories" edge.
func HasAssignmentHistories() predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AssignmentHistoriesTable, ApplicationAssignmentHistoryFieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AssignmentHistoriesTable, AssignmentHistoriesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAssignmentHistoriesWith applies the HasEdge predicate on the "assignment_histories" edge with a given conditions (other predicates).
func HasAssignmentHistoriesWith(preds ...predicate.ApplicationAssignmentHistory) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AssignmentHistoriesInverseTable, ApplicationAssignmentHistoryFieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AssignmentHistoriesTable, AssignmentHistoriesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasStatusHistories applies the HasEdge predicate on the "status_histories" edge.
func HasStatusHistories() predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(StatusHistoriesTable, ApplicationStatusHistoryFieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, StatusHistoriesTable, StatusHistoriesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasStatusHistoriesWith applies the HasEdge predicate on the "status_histories" edge with a given conditions (other predicates).
func HasStatusHistoriesWith(preds ...predicate.ApplicationStatusHistory) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(StatusHistoriesInverseTable, ApplicationStatusHistoryFieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, StatusHistoriesTable, StatusHistoriesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAttachments applies the HasEdge predicate on the "attachments" edge.
func HasAttachments() predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AttachmentsTable, AttachmentFieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AttachmentsTable, AttachmentsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAttachmentsWith applies the HasEdge predicate on the "attachments" edge with a given conditions (other predicates).
func HasAttachmentsWith(preds ...predicate.Attachment) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AttachmentsInverseTable, AttachmentFieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AttachmentsTable, AttachmentsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Application) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Application) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Application) predicate.Application {
	return predicate.Application(func(s *sql.Selector) {
		p(s.Not())
	})
}
