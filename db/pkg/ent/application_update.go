// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/Xanonymous-GitHub/carnival/db/pkg/ent/application"
	"github.com/Xanonymous-GitHub/carnival/db/pkg/ent/applicationassignmenthistory"
	"github.com/Xanonymous-GitHub/carnival/db/pkg/ent/applicationstatushistory"
	"github.com/Xanonymous-GitHub/carnival/db/pkg/ent/attachment"
	"github.com/Xanonymous-GitHub/carnival/db/pkg/ent/predicate"
	"github.com/Xanonymous-GitHub/carnival/db/pkg/ent/ticket"
)

// ApplicationUpdate is the builder for updating Application entities.
type ApplicationUpdate struct {
	config
	hooks    []Hook
	mutation *ApplicationMutation
}

// Where appends a list predicates to the ApplicationUpdate builder.
func (au *ApplicationUpdate) Where(ps ...predicate.Application) *ApplicationUpdate {
	au.mutation.Where(ps...)
	return au
}

// SetBasicID sets the "basic_id" field.
func (au *ApplicationUpdate) SetBasicID(s string) *ApplicationUpdate {
	au.mutation.SetBasicID(s)
	return au
}

// SetPremiumID sets the "premium_id" field.
func (au *ApplicationUpdate) SetPremiumID(s string) *ApplicationUpdate {
	au.mutation.SetPremiumID(s)
	return au
}

// SetBotDisplayName sets the "bot_display_name" field.
func (au *ApplicationUpdate) SetBotDisplayName(s string) *ApplicationUpdate {
	au.mutation.SetBotDisplayName(s)
	return au
}

// SetBotMid sets the "bot_mid" field.
func (au *ApplicationUpdate) SetBotMid(s string) *ApplicationUpdate {
	au.mutation.SetBotMid(s)
	return au
}

// SetBotActiveStatus sets the "bot_active_status" field.
func (au *ApplicationUpdate) SetBotActiveStatus(aas application.BotActiveStatus) *ApplicationUpdate {
	au.mutation.SetBotActiveStatus(aas)
	return au
}

// SetBotSuspendReason sets the "bot_suspend_reason" field.
func (au *ApplicationUpdate) SetBotSuspendReason(asr application.BotSuspendReason) *ApplicationUpdate {
	au.mutation.SetBotSuspendReason(asr)
	return au
}

// SetApplicantName sets the "applicant_name" field.
func (au *ApplicationUpdate) SetApplicantName(s string) *ApplicationUpdate {
	au.mutation.SetApplicantName(s)
	return au
}

// SetApplicantBizID sets the "applicant_biz_id" field.
func (au *ApplicationUpdate) SetApplicantBizID(s string) *ApplicationUpdate {
	au.mutation.SetApplicantBizID(s)
	return au
}

// SetApplicantMid sets the "applicant_mid" field.
func (au *ApplicationUpdate) SetApplicantMid(s string) *ApplicationUpdate {
	au.mutation.SetApplicantMid(s)
	return au
}

// SetApplicantEmail sets the "applicant_email" field.
func (au *ApplicationUpdate) SetApplicantEmail(s string) *ApplicationUpdate {
	au.mutation.SetApplicantEmail(s)
	return au
}

// SetRemark sets the "remark" field.
func (au *ApplicationUpdate) SetRemark(s string) *ApplicationUpdate {
	au.mutation.SetRemark(s)
	return au
}

// SetStoreType sets the "store_type" field.
func (au *ApplicationUpdate) SetStoreType(at application.StoreType) *ApplicationUpdate {
	au.mutation.SetStoreType(at)
	return au
}

// SetWebsiteURL sets the "website_url" field.
func (au *ApplicationUpdate) SetWebsiteURL(s string) *ApplicationUpdate {
	au.mutation.SetWebsiteURL(s)
	return au
}

// SetApplicationStatus sets the "application_status" field.
func (au *ApplicationUpdate) SetApplicationStatus(as application.ApplicationStatus) *ApplicationUpdate {
	au.mutation.SetApplicationStatus(as)
	return au
}

// SetReviewComment sets the "review_comment" field.
func (au *ApplicationUpdate) SetReviewComment(s string) *ApplicationUpdate {
	au.mutation.SetReviewComment(s)
	return au
}

// SetAssigner sets the "assigner" field.
func (au *ApplicationUpdate) SetAssigner(s string) *ApplicationUpdate {
	au.mutation.SetAssigner(s)
	return au
}

// SetAssignee sets the "assignee" field.
func (au *ApplicationUpdate) SetAssignee(s string) *ApplicationUpdate {
	au.mutation.SetAssignee(s)
	return au
}

// SetUpdatedDtime sets the "updated_dtime" field.
func (au *ApplicationUpdate) SetUpdatedDtime(t time.Time) *ApplicationUpdate {
	au.mutation.SetUpdatedDtime(t)
	return au
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by IDs.
func (au *ApplicationUpdate) AddTicketIDs(ids ...int) *ApplicationUpdate {
	au.mutation.AddTicketIDs(ids...)
	return au
}

// AddTickets adds the "tickets" edges to the Ticket entity.
func (au *ApplicationUpdate) AddTickets(t ...*Ticket) *ApplicationUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return au.AddTicketIDs(ids...)
}

// AddAssignmentHistoryIDs adds the "assignment_histories" edge to the ApplicationAssignmentHistory entity by IDs.
func (au *ApplicationUpdate) AddAssignmentHistoryIDs(ids ...int) *ApplicationUpdate {
	au.mutation.AddAssignmentHistoryIDs(ids...)
	return au
}

// AddAssignmentHistories adds the "assignment_histories" edges to the ApplicationAssignmentHistory entity.
func (au *ApplicationUpdate) AddAssignmentHistories(a ...*ApplicationAssignmentHistory) *ApplicationUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddAssignmentHistoryIDs(ids...)
}

// AddStatusHistoryIDs adds the "status_histories" edge to the ApplicationStatusHistory entity by IDs.
func (au *ApplicationUpdate) AddStatusHistoryIDs(ids ...int) *ApplicationUpdate {
	au.mutation.AddStatusHistoryIDs(ids...)
	return au
}

// AddStatusHistories adds the "status_histories" edges to the ApplicationStatusHistory entity.
func (au *ApplicationUpdate) AddStatusHistories(a ...*ApplicationStatusHistory) *ApplicationUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddStatusHistoryIDs(ids...)
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by IDs.
func (au *ApplicationUpdate) AddAttachmentIDs(ids ...int) *ApplicationUpdate {
	au.mutation.AddAttachmentIDs(ids...)
	return au
}

// AddAttachments adds the "attachments" edges to the Attachment entity.
func (au *ApplicationUpdate) AddAttachments(a ...*Attachment) *ApplicationUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddAttachmentIDs(ids...)
}

// Mutation returns the ApplicationMutation object of the builder.
func (au *ApplicationUpdate) Mutation() *ApplicationMutation {
	return au.mutation
}

// ClearTickets clears all "tickets" edges to the Ticket entity.
func (au *ApplicationUpdate) ClearTickets() *ApplicationUpdate {
	au.mutation.ClearTickets()
	return au
}

// RemoveTicketIDs removes the "tickets" edge to Ticket entities by IDs.
func (au *ApplicationUpdate) RemoveTicketIDs(ids ...int) *ApplicationUpdate {
	au.mutation.RemoveTicketIDs(ids...)
	return au
}

// RemoveTickets removes "tickets" edges to Ticket entities.
func (au *ApplicationUpdate) RemoveTickets(t ...*Ticket) *ApplicationUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return au.RemoveTicketIDs(ids...)
}

// ClearAssignmentHistories clears all "assignment_histories" edges to the ApplicationAssignmentHistory entity.
func (au *ApplicationUpdate) ClearAssignmentHistories() *ApplicationUpdate {
	au.mutation.ClearAssignmentHistories()
	return au
}

// RemoveAssignmentHistoryIDs removes the "assignment_histories" edge to ApplicationAssignmentHistory entities by IDs.
func (au *ApplicationUpdate) RemoveAssignmentHistoryIDs(ids ...int) *ApplicationUpdate {
	au.mutation.RemoveAssignmentHistoryIDs(ids...)
	return au
}

// RemoveAssignmentHistories removes "assignment_histories" edges to ApplicationAssignmentHistory entities.
func (au *ApplicationUpdate) RemoveAssignmentHistories(a ...*ApplicationAssignmentHistory) *ApplicationUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveAssignmentHistoryIDs(ids...)
}

// ClearStatusHistories clears all "status_histories" edges to the ApplicationStatusHistory entity.
func (au *ApplicationUpdate) ClearStatusHistories() *ApplicationUpdate {
	au.mutation.ClearStatusHistories()
	return au
}

// RemoveStatusHistoryIDs removes the "status_histories" edge to ApplicationStatusHistory entities by IDs.
func (au *ApplicationUpdate) RemoveStatusHistoryIDs(ids ...int) *ApplicationUpdate {
	au.mutation.RemoveStatusHistoryIDs(ids...)
	return au
}

// RemoveStatusHistories removes "status_histories" edges to ApplicationStatusHistory entities.
func (au *ApplicationUpdate) RemoveStatusHistories(a ...*ApplicationStatusHistory) *ApplicationUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveStatusHistoryIDs(ids...)
}

// ClearAttachments clears all "attachments" edges to the Attachment entity.
func (au *ApplicationUpdate) ClearAttachments() *ApplicationUpdate {
	au.mutation.ClearAttachments()
	return au
}

// RemoveAttachmentIDs removes the "attachments" edge to Attachment entities by IDs.
func (au *ApplicationUpdate) RemoveAttachmentIDs(ids ...int) *ApplicationUpdate {
	au.mutation.RemoveAttachmentIDs(ids...)
	return au
}

// RemoveAttachments removes "attachments" edges to Attachment entities.
func (au *ApplicationUpdate) RemoveAttachments(a ...*Attachment) *ApplicationUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveAttachmentIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (au *ApplicationUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(au.hooks) == 0 {
		if err = au.check(); err != nil {
			return 0, err
		}
		affected, err = au.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ApplicationMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = au.check(); err != nil {
				return 0, err
			}
			au.mutation = mutation
			affected, err = au.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(au.hooks) - 1; i >= 0; i-- {
			if au.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = au.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, au.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (au *ApplicationUpdate) SaveX(ctx context.Context) int {
	affected, err := au.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (au *ApplicationUpdate) Exec(ctx context.Context) error {
	_, err := au.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (au *ApplicationUpdate) ExecX(ctx context.Context) {
	if err := au.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (au *ApplicationUpdate) check() error {
	if v, ok := au.mutation.BasicID(); ok {
		if err := application.BasicIDValidator(v); err != nil {
			return &ValidationError{Name: "basic_id", err: fmt.Errorf(`ent: validator failed for field "Application.basic_id": %w`, err)}
		}
	}
	if v, ok := au.mutation.PremiumID(); ok {
		if err := application.PremiumIDValidator(v); err != nil {
			return &ValidationError{Name: "premium_id", err: fmt.Errorf(`ent: validator failed for field "Application.premium_id": %w`, err)}
		}
	}
	if v, ok := au.mutation.BotDisplayName(); ok {
		if err := application.BotDisplayNameValidator(v); err != nil {
			return &ValidationError{Name: "bot_display_name", err: fmt.Errorf(`ent: validator failed for field "Application.bot_display_name": %w`, err)}
		}
	}
	if v, ok := au.mutation.BotMid(); ok {
		if err := application.BotMidValidator(v); err != nil {
			return &ValidationError{Name: "bot_mid", err: fmt.Errorf(`ent: validator failed for field "Application.bot_mid": %w`, err)}
		}
	}
	if v, ok := au.mutation.BotActiveStatus(); ok {
		if err := application.BotActiveStatusValidator(v); err != nil {
			return &ValidationError{Name: "bot_active_status", err: fmt.Errorf(`ent: validator failed for field "Application.bot_active_status": %w`, err)}
		}
	}
	if v, ok := au.mutation.BotSuspendReason(); ok {
		if err := application.BotSuspendReasonValidator(v); err != nil {
			return &ValidationError{Name: "bot_suspend_reason", err: fmt.Errorf(`ent: validator failed for field "Application.bot_suspend_reason": %w`, err)}
		}
	}
	if v, ok := au.mutation.ApplicantName(); ok {
		if err := application.ApplicantNameValidator(v); err != nil {
			return &ValidationError{Name: "applicant_name", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_name": %w`, err)}
		}
	}
	if v, ok := au.mutation.ApplicantBizID(); ok {
		if err := application.ApplicantBizIDValidator(v); err != nil {
			return &ValidationError{Name: "applicant_biz_id", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_biz_id": %w`, err)}
		}
	}
	if v, ok := au.mutation.ApplicantMid(); ok {
		if err := application.ApplicantMidValidator(v); err != nil {
			return &ValidationError{Name: "applicant_mid", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_mid": %w`, err)}
		}
	}
	if v, ok := au.mutation.ApplicantEmail(); ok {
		if err := application.ApplicantEmailValidator(v); err != nil {
			return &ValidationError{Name: "applicant_email", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_email": %w`, err)}
		}
	}
	if v, ok := au.mutation.Remark(); ok {
		if err := application.RemarkValidator(v); err != nil {
			return &ValidationError{Name: "remark", err: fmt.Errorf(`ent: validator failed for field "Application.remark": %w`, err)}
		}
	}
	if v, ok := au.mutation.StoreType(); ok {
		if err := application.StoreTypeValidator(v); err != nil {
			return &ValidationError{Name: "store_type", err: fmt.Errorf(`ent: validator failed for field "Application.store_type": %w`, err)}
		}
	}
	if v, ok := au.mutation.ApplicationStatus(); ok {
		if err := application.ApplicationStatusValidator(v); err != nil {
			return &ValidationError{Name: "application_status", err: fmt.Errorf(`ent: validator failed for field "Application.application_status": %w`, err)}
		}
	}
	if v, ok := au.mutation.Assigner(); ok {
		if err := application.AssignerValidator(v); err != nil {
			return &ValidationError{Name: "assigner", err: fmt.Errorf(`ent: validator failed for field "Application.assigner": %w`, err)}
		}
	}
	if v, ok := au.mutation.Assignee(); ok {
		if err := application.AssigneeValidator(v); err != nil {
			return &ValidationError{Name: "assignee", err: fmt.Errorf(`ent: validator failed for field "Application.assignee": %w`, err)}
		}
	}
	return nil
}

func (au *ApplicationUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   application.Table,
			Columns: application.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: application.FieldID,
			},
		},
	}
	if ps := au.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := au.mutation.BasicID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldBasicID,
		})
	}
	if value, ok := au.mutation.PremiumID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldPremiumID,
		})
	}
	if value, ok := au.mutation.BotDisplayName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldBotDisplayName,
		})
	}
	if value, ok := au.mutation.BotMid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldBotMid,
		})
	}
	if value, ok := au.mutation.BotActiveStatus(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldBotActiveStatus,
		})
	}
	if value, ok := au.mutation.BotSuspendReason(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldBotSuspendReason,
		})
	}
	if value, ok := au.mutation.ApplicantName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantName,
		})
	}
	if value, ok := au.mutation.ApplicantBizID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantBizID,
		})
	}
	if value, ok := au.mutation.ApplicantMid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantMid,
		})
	}
	if value, ok := au.mutation.ApplicantEmail(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantEmail,
		})
	}
	if value, ok := au.mutation.Remark(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldRemark,
		})
	}
	if value, ok := au.mutation.StoreType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldStoreType,
		})
	}
	if value, ok := au.mutation.WebsiteURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldWebsiteURL,
		})
	}
	if value, ok := au.mutation.ApplicationStatus(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldApplicationStatus,
		})
	}
	if value, ok := au.mutation.ReviewComment(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldReviewComment,
		})
	}
	if value, ok := au.mutation.Assigner(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldAssigner,
		})
	}
	if value, ok := au.mutation.Assignee(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldAssignee,
		})
	}
	if value, ok := au.mutation.UpdatedDtime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: application.FieldUpdatedDtime,
		})
	}
	if au.mutation.TicketsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.TicketsTable,
			Columns: []string{application.TicketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: ticket.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedTicketsIDs(); len(nodes) > 0 && !au.mutation.TicketsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.TicketsTable,
			Columns: []string{application.TicketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: ticket.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.TicketsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.TicketsTable,
			Columns: []string{application.TicketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: ticket.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.AssignmentHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AssignmentHistoriesTable,
			Columns: []string{application.AssignmentHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationassignmenthistory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedAssignmentHistoriesIDs(); len(nodes) > 0 && !au.mutation.AssignmentHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AssignmentHistoriesTable,
			Columns: []string{application.AssignmentHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationassignmenthistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.AssignmentHistoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AssignmentHistoriesTable,
			Columns: []string{application.AssignmentHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationassignmenthistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.StatusHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.StatusHistoriesTable,
			Columns: []string{application.StatusHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationstatushistory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedStatusHistoriesIDs(); len(nodes) > 0 && !au.mutation.StatusHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.StatusHistoriesTable,
			Columns: []string{application.StatusHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationstatushistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.StatusHistoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.StatusHistoriesTable,
			Columns: []string{application.StatusHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationstatushistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.AttachmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AttachmentsTable,
			Columns: []string{application.AttachmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedAttachmentsIDs(); len(nodes) > 0 && !au.mutation.AttachmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AttachmentsTable,
			Columns: []string{application.AttachmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.AttachmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AttachmentsTable,
			Columns: []string{application.AttachmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, au.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{application.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return 0, err
	}
	return n, nil
}

// ApplicationUpdateOne is the builder for updating a single Application entity.
type ApplicationUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ApplicationMutation
}

// SetBasicID sets the "basic_id" field.
func (auo *ApplicationUpdateOne) SetBasicID(s string) *ApplicationUpdateOne {
	auo.mutation.SetBasicID(s)
	return auo
}

// SetPremiumID sets the "premium_id" field.
func (auo *ApplicationUpdateOne) SetPremiumID(s string) *ApplicationUpdateOne {
	auo.mutation.SetPremiumID(s)
	return auo
}

// SetBotDisplayName sets the "bot_display_name" field.
func (auo *ApplicationUpdateOne) SetBotDisplayName(s string) *ApplicationUpdateOne {
	auo.mutation.SetBotDisplayName(s)
	return auo
}

// SetBotMid sets the "bot_mid" field.
func (auo *ApplicationUpdateOne) SetBotMid(s string) *ApplicationUpdateOne {
	auo.mutation.SetBotMid(s)
	return auo
}

// SetBotActiveStatus sets the "bot_active_status" field.
func (auo *ApplicationUpdateOne) SetBotActiveStatus(aas application.BotActiveStatus) *ApplicationUpdateOne {
	auo.mutation.SetBotActiveStatus(aas)
	return auo
}

// SetBotSuspendReason sets the "bot_suspend_reason" field.
func (auo *ApplicationUpdateOne) SetBotSuspendReason(asr application.BotSuspendReason) *ApplicationUpdateOne {
	auo.mutation.SetBotSuspendReason(asr)
	return auo
}

// SetApplicantName sets the "applicant_name" field.
func (auo *ApplicationUpdateOne) SetApplicantName(s string) *ApplicationUpdateOne {
	auo.mutation.SetApplicantName(s)
	return auo
}

// SetApplicantBizID sets the "applicant_biz_id" field.
func (auo *ApplicationUpdateOne) SetApplicantBizID(s string) *ApplicationUpdateOne {
	auo.mutation.SetApplicantBizID(s)
	return auo
}

// SetApplicantMid sets the "applicant_mid" field.
func (auo *ApplicationUpdateOne) SetApplicantMid(s string) *ApplicationUpdateOne {
	auo.mutation.SetApplicantMid(s)
	return auo
}

// SetApplicantEmail sets the "applicant_email" field.
func (auo *ApplicationUpdateOne) SetApplicantEmail(s string) *ApplicationUpdateOne {
	auo.mutation.SetApplicantEmail(s)
	return auo
}

// SetRemark sets the "remark" field.
func (auo *ApplicationUpdateOne) SetRemark(s string) *ApplicationUpdateOne {
	auo.mutation.SetRemark(s)
	return auo
}

// SetStoreType sets the "store_type" field.
func (auo *ApplicationUpdateOne) SetStoreType(at application.StoreType) *ApplicationUpdateOne {
	auo.mutation.SetStoreType(at)
	return auo
}

// SetWebsiteURL sets the "website_url" field.
func (auo *ApplicationUpdateOne) SetWebsiteURL(s string) *ApplicationUpdateOne {
	auo.mutation.SetWebsiteURL(s)
	return auo
}

// SetApplicationStatus sets the "application_status" field.
func (auo *ApplicationUpdateOne) SetApplicationStatus(as application.ApplicationStatus) *ApplicationUpdateOne {
	auo.mutation.SetApplicationStatus(as)
	return auo
}

// SetReviewComment sets the "review_comment" field.
func (auo *ApplicationUpdateOne) SetReviewComment(s string) *ApplicationUpdateOne {
	auo.mutation.SetReviewComment(s)
	return auo
}

// SetAssigner sets the "assigner" field.
func (auo *ApplicationUpdateOne) SetAssigner(s string) *ApplicationUpdateOne {
	auo.mutation.SetAssigner(s)
	return auo
}

// SetAssignee sets the "assignee" field.
func (auo *ApplicationUpdateOne) SetAssignee(s string) *ApplicationUpdateOne {
	auo.mutation.SetAssignee(s)
	return auo
}

// SetUpdatedDtime sets the "updated_dtime" field.
func (auo *ApplicationUpdateOne) SetUpdatedDtime(t time.Time) *ApplicationUpdateOne {
	auo.mutation.SetUpdatedDtime(t)
	return auo
}

// AddTicketIDs adds the "tickets" edge to the Ticket entity by IDs.
func (auo *ApplicationUpdateOne) AddTicketIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.AddTicketIDs(ids...)
	return auo
}

// AddTickets adds the "tickets" edges to the Ticket entity.
func (auo *ApplicationUpdateOne) AddTickets(t ...*Ticket) *ApplicationUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return auo.AddTicketIDs(ids...)
}

// AddAssignmentHistoryIDs adds the "assignment_histories" edge to the ApplicationAssignmentHistory entity by IDs.
func (auo *ApplicationUpdateOne) AddAssignmentHistoryIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.AddAssignmentHistoryIDs(ids...)
	return auo
}

// AddAssignmentHistories adds the "assignment_histories" edges to the ApplicationAssignmentHistory entity.
func (auo *ApplicationUpdateOne) AddAssignmentHistories(a ...*ApplicationAssignmentHistory) *ApplicationUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddAssignmentHistoryIDs(ids...)
}

// AddStatusHistoryIDs adds the "status_histories" edge to the ApplicationStatusHistory entity by IDs.
func (auo *ApplicationUpdateOne) AddStatusHistoryIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.AddStatusHistoryIDs(ids...)
	return auo
}

// AddStatusHistories adds the "status_histories" edges to the ApplicationStatusHistory entity.
func (auo *ApplicationUpdateOne) AddStatusHistories(a ...*ApplicationStatusHistory) *ApplicationUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddStatusHistoryIDs(ids...)
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by IDs.
func (auo *ApplicationUpdateOne) AddAttachmentIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.AddAttachmentIDs(ids...)
	return auo
}

// AddAttachments adds the "attachments" edges to the Attachment entity.
func (auo *ApplicationUpdateOne) AddAttachments(a ...*Attachment) *ApplicationUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddAttachmentIDs(ids...)
}

// Mutation returns the ApplicationMutation object of the builder.
func (auo *ApplicationUpdateOne) Mutation() *ApplicationMutation {
	return auo.mutation
}

// ClearTickets clears all "tickets" edges to the Ticket entity.
func (auo *ApplicationUpdateOne) ClearTickets() *ApplicationUpdateOne {
	auo.mutation.ClearTickets()
	return auo
}

// RemoveTicketIDs removes the "tickets" edge to Ticket entities by IDs.
func (auo *ApplicationUpdateOne) RemoveTicketIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.RemoveTicketIDs(ids...)
	return auo
}

// RemoveTickets removes "tickets" edges to Ticket entities.
func (auo *ApplicationUpdateOne) RemoveTickets(t ...*Ticket) *ApplicationUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return auo.RemoveTicketIDs(ids...)
}

// ClearAssignmentHistories clears all "assignment_histories" edges to the ApplicationAssignmentHistory entity.
func (auo *ApplicationUpdateOne) ClearAssignmentHistories() *ApplicationUpdateOne {
	auo.mutation.ClearAssignmentHistories()
	return auo
}

// RemoveAssignmentHistoryIDs removes the "assignment_histories" edge to ApplicationAssignmentHistory entities by IDs.
func (auo *ApplicationUpdateOne) RemoveAssignmentHistoryIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.RemoveAssignmentHistoryIDs(ids...)
	return auo
}

// RemoveAssignmentHistories removes "assignment_histories" edges to ApplicationAssignmentHistory entities.
func (auo *ApplicationUpdateOne) RemoveAssignmentHistories(a ...*ApplicationAssignmentHistory) *ApplicationUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveAssignmentHistoryIDs(ids...)
}

// ClearStatusHistories clears all "status_histories" edges to the ApplicationStatusHistory entity.
func (auo *ApplicationUpdateOne) ClearStatusHistories() *ApplicationUpdateOne {
	auo.mutation.ClearStatusHistories()
	return auo
}

// RemoveStatusHistoryIDs removes the "status_histories" edge to ApplicationStatusHistory entities by IDs.
func (auo *ApplicationUpdateOne) RemoveStatusHistoryIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.RemoveStatusHistoryIDs(ids...)
	return auo
}

// RemoveStatusHistories removes "status_histories" edges to ApplicationStatusHistory entities.
func (auo *ApplicationUpdateOne) RemoveStatusHistories(a ...*ApplicationStatusHistory) *ApplicationUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveStatusHistoryIDs(ids...)
}

// ClearAttachments clears all "attachments" edges to the Attachment entity.
func (auo *ApplicationUpdateOne) ClearAttachments() *ApplicationUpdateOne {
	auo.mutation.ClearAttachments()
	return auo
}

// RemoveAttachmentIDs removes the "attachments" edge to Attachment entities by IDs.
func (auo *ApplicationUpdateOne) RemoveAttachmentIDs(ids ...int) *ApplicationUpdateOne {
	auo.mutation.RemoveAttachmentIDs(ids...)
	return auo
}

// RemoveAttachments removes "attachments" edges to Attachment entities.
func (auo *ApplicationUpdateOne) RemoveAttachments(a ...*Attachment) *ApplicationUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveAttachmentIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (auo *ApplicationUpdateOne) Select(field string, fields ...string) *ApplicationUpdateOne {
	auo.fields = append([]string{field}, fields...)
	return auo
}

// Save executes the query and returns the updated Application entity.
func (auo *ApplicationUpdateOne) Save(ctx context.Context) (*Application, error) {
	var (
		err  error
		node *Application
	)
	if len(auo.hooks) == 0 {
		if err = auo.check(); err != nil {
			return nil, err
		}
		node, err = auo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ApplicationMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = auo.check(); err != nil {
				return nil, err
			}
			auo.mutation = mutation
			node, err = auo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(auo.hooks) - 1; i >= 0; i-- {
			if auo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = auo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, auo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (auo *ApplicationUpdateOne) SaveX(ctx context.Context) *Application {
	node, err := auo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (auo *ApplicationUpdateOne) Exec(ctx context.Context) error {
	_, err := auo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (auo *ApplicationUpdateOne) ExecX(ctx context.Context) {
	if err := auo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (auo *ApplicationUpdateOne) check() error {
	if v, ok := auo.mutation.BasicID(); ok {
		if err := application.BasicIDValidator(v); err != nil {
			return &ValidationError{Name: "basic_id", err: fmt.Errorf(`ent: validator failed for field "Application.basic_id": %w`, err)}
		}
	}
	if v, ok := auo.mutation.PremiumID(); ok {
		if err := application.PremiumIDValidator(v); err != nil {
			return &ValidationError{Name: "premium_id", err: fmt.Errorf(`ent: validator failed for field "Application.premium_id": %w`, err)}
		}
	}
	if v, ok := auo.mutation.BotDisplayName(); ok {
		if err := application.BotDisplayNameValidator(v); err != nil {
			return &ValidationError{Name: "bot_display_name", err: fmt.Errorf(`ent: validator failed for field "Application.bot_display_name": %w`, err)}
		}
	}
	if v, ok := auo.mutation.BotMid(); ok {
		if err := application.BotMidValidator(v); err != nil {
			return &ValidationError{Name: "bot_mid", err: fmt.Errorf(`ent: validator failed for field "Application.bot_mid": %w`, err)}
		}
	}
	if v, ok := auo.mutation.BotActiveStatus(); ok {
		if err := application.BotActiveStatusValidator(v); err != nil {
			return &ValidationError{Name: "bot_active_status", err: fmt.Errorf(`ent: validator failed for field "Application.bot_active_status": %w`, err)}
		}
	}
	if v, ok := auo.mutation.BotSuspendReason(); ok {
		if err := application.BotSuspendReasonValidator(v); err != nil {
			return &ValidationError{Name: "bot_suspend_reason", err: fmt.Errorf(`ent: validator failed for field "Application.bot_suspend_reason": %w`, err)}
		}
	}
	if v, ok := auo.mutation.ApplicantName(); ok {
		if err := application.ApplicantNameValidator(v); err != nil {
			return &ValidationError{Name: "applicant_name", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_name": %w`, err)}
		}
	}
	if v, ok := auo.mutation.ApplicantBizID(); ok {
		if err := application.ApplicantBizIDValidator(v); err != nil {
			return &ValidationError{Name: "applicant_biz_id", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_biz_id": %w`, err)}
		}
	}
	if v, ok := auo.mutation.ApplicantMid(); ok {
		if err := application.ApplicantMidValidator(v); err != nil {
			return &ValidationError{Name: "applicant_mid", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_mid": %w`, err)}
		}
	}
	if v, ok := auo.mutation.ApplicantEmail(); ok {
		if err := application.ApplicantEmailValidator(v); err != nil {
			return &ValidationError{Name: "applicant_email", err: fmt.Errorf(`ent: validator failed for field "Application.applicant_email": %w`, err)}
		}
	}
	if v, ok := auo.mutation.Remark(); ok {
		if err := application.RemarkValidator(v); err != nil {
			return &ValidationError{Name: "remark", err: fmt.Errorf(`ent: validator failed for field "Application.remark": %w`, err)}
		}
	}
	if v, ok := auo.mutation.StoreType(); ok {
		if err := application.StoreTypeValidator(v); err != nil {
			return &ValidationError{Name: "store_type", err: fmt.Errorf(`ent: validator failed for field "Application.store_type": %w`, err)}
		}
	}
	if v, ok := auo.mutation.ApplicationStatus(); ok {
		if err := application.ApplicationStatusValidator(v); err != nil {
			return &ValidationError{Name: "application_status", err: fmt.Errorf(`ent: validator failed for field "Application.application_status": %w`, err)}
		}
	}
	if v, ok := auo.mutation.Assigner(); ok {
		if err := application.AssignerValidator(v); err != nil {
			return &ValidationError{Name: "assigner", err: fmt.Errorf(`ent: validator failed for field "Application.assigner": %w`, err)}
		}
	}
	if v, ok := auo.mutation.Assignee(); ok {
		if err := application.AssigneeValidator(v); err != nil {
			return &ValidationError{Name: "assignee", err: fmt.Errorf(`ent: validator failed for field "Application.assignee": %w`, err)}
		}
	}
	return nil
}

func (auo *ApplicationUpdateOne) sqlSave(ctx context.Context) (_node *Application, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   application.Table,
			Columns: application.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: application.FieldID,
			},
		},
	}
	id, ok := auo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Application.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := auo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, application.FieldID)
		for _, f := range fields {
			if !application.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != application.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := auo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := auo.mutation.BasicID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldBasicID,
		})
	}
	if value, ok := auo.mutation.PremiumID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldPremiumID,
		})
	}
	if value, ok := auo.mutation.BotDisplayName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldBotDisplayName,
		})
	}
	if value, ok := auo.mutation.BotMid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldBotMid,
		})
	}
	if value, ok := auo.mutation.BotActiveStatus(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldBotActiveStatus,
		})
	}
	if value, ok := auo.mutation.BotSuspendReason(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldBotSuspendReason,
		})
	}
	if value, ok := auo.mutation.ApplicantName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantName,
		})
	}
	if value, ok := auo.mutation.ApplicantBizID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantBizID,
		})
	}
	if value, ok := auo.mutation.ApplicantMid(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantMid,
		})
	}
	if value, ok := auo.mutation.ApplicantEmail(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldApplicantEmail,
		})
	}
	if value, ok := auo.mutation.Remark(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldRemark,
		})
	}
	if value, ok := auo.mutation.StoreType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldStoreType,
		})
	}
	if value, ok := auo.mutation.WebsiteURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldWebsiteURL,
		})
	}
	if value, ok := auo.mutation.ApplicationStatus(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: application.FieldApplicationStatus,
		})
	}
	if value, ok := auo.mutation.ReviewComment(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldReviewComment,
		})
	}
	if value, ok := auo.mutation.Assigner(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldAssigner,
		})
	}
	if value, ok := auo.mutation.Assignee(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: application.FieldAssignee,
		})
	}
	if value, ok := auo.mutation.UpdatedDtime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: application.FieldUpdatedDtime,
		})
	}
	if auo.mutation.TicketsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.TicketsTable,
			Columns: []string{application.TicketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: ticket.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedTicketsIDs(); len(nodes) > 0 && !auo.mutation.TicketsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.TicketsTable,
			Columns: []string{application.TicketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: ticket.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.TicketsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.TicketsTable,
			Columns: []string{application.TicketsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: ticket.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.AssignmentHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AssignmentHistoriesTable,
			Columns: []string{application.AssignmentHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationassignmenthistory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedAssignmentHistoriesIDs(); len(nodes) > 0 && !auo.mutation.AssignmentHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AssignmentHistoriesTable,
			Columns: []string{application.AssignmentHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationassignmenthistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.AssignmentHistoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AssignmentHistoriesTable,
			Columns: []string{application.AssignmentHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationassignmenthistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.StatusHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.StatusHistoriesTable,
			Columns: []string{application.StatusHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationstatushistory.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedStatusHistoriesIDs(); len(nodes) > 0 && !auo.mutation.StatusHistoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.StatusHistoriesTable,
			Columns: []string{application.StatusHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationstatushistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.StatusHistoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.StatusHistoriesTable,
			Columns: []string{application.StatusHistoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: applicationstatushistory.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.AttachmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AttachmentsTable,
			Columns: []string{application.AttachmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedAttachmentsIDs(); len(nodes) > 0 && !auo.mutation.AttachmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AttachmentsTable,
			Columns: []string{application.AttachmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.AttachmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   application.AttachmentsTable,
			Columns: []string{application.AttachmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: attachment.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Application{config: auo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, auo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{application.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	return _node, nil
}
